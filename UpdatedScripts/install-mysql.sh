#! /bin/bash

ROOTPASS="Mysql@123"

LOG_FILE="/var/log/cloudera-azure-initialize.log"

file='/tmp/mysql.sql'
> $file


# manually set EXECNAME because this file is called from another script and it $0 is "bash"
EXECNAME="install-mysql.sh"
CURRENT_VERSION_MARKER='Azure_1'
SLEEP_INTERVAL=5

# logs everything to the $LOG_FILE
log() {
  echo "$(date) [${EXECNAME}]: $*" >> "${LOG_FILE}"
}

fail_or_continue()
{
    local RET=$1
    local STR=$2
    if [[ $RET -ne 0 ]]; then
	    stop_db #Chai#
        if [[ -z $STR ]]; then
            STR="--> Error $RET"
        fi
        log "$STR, giving up"
        log "------- initialize-mysql.sh failed -------"
        exit "$RET"
    fi
}

create_database()
{
  local DBNAME=$1
  local PW=$2
  local USER=$3

        #echo "create database $DBNAME default character set utf8;" >> $file
        #echo "grant all on $DBNAME.* to '$USER'@'localhost' identified by '\"$PW\"';" >> $file
        #echo "grant all on $DBNAME.* to '$USER'@'%' identified by '\"$PW\"';" >> $file
		
		echo "create database $DBNAME default character set utf8;" >> $file  #Chai#
        echo "grant all on *.* to '$USER'@'localhost' identified by '\"$PW\"' with grant option;" >> $file  #Chai#
        echo "grant all on *.* to '$USER'@'%' identified by '\"$PW\"' with grant option;" >> $file  #Chai#

  fail_or_continue $? "Unable to create database role $USER"
  echo "CREATE DATABASE $DBNAME OWNER $USER;"
  
        echo "grant all on *.* to 'temp'@'localhost' identified by 'Password@123' with grant option;" >> $file  #Chai#
        echo "grant all on *.* to 'temp'@'%' identified by 'Password@123' with grant option;" >> $file          #Chai#
}

create_db()
{
echo "FLUSH PRIVILEGES;" >> $file
sed -i 's/"//g' $file
#mysql -u root -p$ROOTPASS < $file 2>/dev/null
mysql -u root -p$ROOTPASS < $file #Chai#
}

# Returns 0 if the given DB exists in the DB list file.
db_exists()
{
  grep -q -s -e "^$1$" "$DB_LIST_FILE"
}

#create_random_password()
#{
#  perl -le 'print map { ("a".."z", "A".."Z", 0..9)[rand 62] } 1..10'
#}
create_random_password()    #Chai#
{                           #Chai#
  perl -le 'print map { ("a".."z", "A".."Z", 0..9, "@")[rand 62] } 1..10'  #Chai#
}                            #Chai#

# Creates the SCM database, if it doesn't exist yet.
create_scm_db()
{
  local db=scm
  local pw=$1
  local user=scm

  if db_exists $db; then
    return 0
  fi

  echo "Creating DB $db for role $role"
  local pw
 # pw=$(create_random_password)  #Chai#
   pw="Mysql@1234"   #Chai#
  create_database "$db" "$pw" "$user"

  orig_umask=$(umask)
  umask 0077
  echo "Creating SCM configuration file: $DB_PROP_FILE"
  cat > "$DB_PROP_FILE" << EOF
# Auto-generated by `basename $0`
#
# $NOW
#
# These are database settings for CM Manager
#
com.cloudera.cmf.db.type=mysql
com.cloudera.cmf.db.host=localhost:$DB_PORT
com.cloudera.cmf.db.name=scm
com.cloudera.cmf.db.user=scm
com.cloudera.cmf.db.password=$pw
EOF

  umask "$orig_umask"
  fail_or_continue $? "Error creating file $DB_PROP_FILE"
  echo "Created db properties file $DB_PROP_FILE"
  backup_file "$DB_LIST_FILE"
  echo scm >> "$DB_LIST_FILE"
}

create_hive_metastore()
{
  # $1 is the MgmtServiceHandler.RoleNames Enum value
  # $2 is the database name.
  # hive has different db name and role name
  local db='metastore'     #Chai#
  local user='hive'     #Chai#

  if db_exists $db; then
    return 0
  fi

  echo "Creating DB $db for role $role"
  local pw
  pw=$(create_random_password)  #Chai#
  #pw="Mysql@1234"   #Chai#
  create_database "$db" "$pw" "$user"
  
  log create_database "$db" "$pw" "$user"  #Chai#


  if [[ $MGMT_DB_MODIFIED -eq 0 ]]; then
    backup_file "$MGMT_DB_PROP_FILE"
  fi
  MGMT_DB_MODIFIED=1

  # Write the prop file header.
  if [[ ! -f $MGMT_DB_PROP_FILE ]]; then
    orig_umask=$(umask)
    umask 0077
    cat > "$MGMT_DB_PROP_FILE" << EOF
# Auto-generated by `basename $0`
#
# $NOW
#
# These are database credentials for databases
# created by "cloudera-scm-server-db" for
# Cloudera Manager Management Services,
# to be used during the installation wizard if
# the embedded database route is taken.
#
# The source of truth for these settings
# is the Cloudera Manager databases and
# changes made here will not be reflected
# there automatically.
#
EOF

    umask "$orig_umask"
    fail_or_continue $? "Error creating file $MGMT_DB_PROP_FILE"
  fi

  local PREFIX="com.cloudera.cmf.$user.db"

  # Append the role db properties to the mgmt db props file.
  cat >> "$MGMT_DB_PROP_FILE" <<EOF
$PREFIX.type=mysql
$PREFIX.host=$DB_HOSTPORT
$PREFIX.name=$db
$PREFIX.user=$user
$PREFIX.password=$pw
EOF
  fail_or_continue $? "Error updating file $MGMT_DB_PROP_FILE"

   backup_file "$DB_LIST_FILE"
  echo "$db" >> "$DB_LIST_FILE"
}


# Creates a database for a specific role, if it doesn't exist yet.
create_db_and_user()
{
  # $1 is the MgmtServiceHandler.RoleNames Enum value
  # $2 is the database name.
  local user=$1
  local db=$2

  if db_exists "$db"; then
    return 0
  fi

  echo "Creating DB $db for user $user"
  local pw
 # pw=$(create_random_password)  #Chai#
   pw="Mysql@1234"    #Chai#
  create_database "$db" "$pw" "$user"

  if [[ $MGMT_DB_MODIFIED -eq 0 ]]; then
    backup_file "$MGMT_DB_PROP_FILE"
  fi
  MGMT_DB_MODIFIED=1

  # Write the prop file header.
  if [[ ! -f $MGMT_DB_PROP_FILE ]]; then
    orig_umask=$(umask)
    umask 0077
    cat > "$MGMT_DB_PROP_FILE" << EOF
# Auto-generated by `basename $0`
#
# $NOW
#
# These are database credentials for databases
# created by "cloudera-scm-server-db" for
# Cloudera Manager Management Services,
# to be used during the installation wizard if
# the embedded database route is taken.
#
# The source of truth for these settings
# is the Cloudera Manager databases and
# changes made here will not be reflected
# there automatically.
#
EOF

    umask "$orig_umask"
    fail_or_continue $? "Error creating file $MGMT_DB_PROP_FILE"
  fi

  local PREFIX="com.cloudera.cmf.$user.db"

  # Append the role db properties to the mgmt db props file.
  cat >> "$MGMT_DB_PROP_FILE" <<EOF
$PREFIX.type=mysql
$PREFIX.host=$DB_HOSTPORT
$PREFIX.name=$db
$PREFIX.user=$db
$PREFIX.password=$pw
EOF
  fail_or_continue $? "Error updating file $MGMT_DB_PROP_FILE"


  backup_file "$DB_LIST_FILE"
  echo "$db" >> "$DB_LIST_FILE"
}


# Get the amount of RAM on the system. Uses "free -b" to get the amount
# in bytes and parses the output to get total amount of memory available.
get_system_ram()
{
  local free_output
  free_output=$(free -b | grep Mem)
  local regex="Mem:[[:space:]]+([[:digit:]]+)"
  if [[ $free_output =~ $regex ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    fail_or_continue 1 "Unable to find amount of RAM on the system"
  fi
}

# We need to set a good value for mysql shared_buffer parameter. Default
# is 32 MB which is too low. Postgresql recommends setting this to 1/4 of RAM
# if there is more than 1GB of RAM on the system (which is true for most systems
# today). This parameter also depends on the Linux maximum shared memory parameter
# (cat /proc/sys/kernel/shmmax)
# Few linux systems default the shmmax to 32 MB, below that level we should let
# mysql default as is. Above this value, we will use 50% of the shmmax as
# the shared_buffer default value. Also maximum recommended value is 8GB, so
# we will ceil on 8 GB.
#
# shared_buffer is specified in kernel buffer cache block size, typically
# 1024 bytes (8192 bits). So the shared_buffer value * 8192 gives the memory
# in bits that will be used (actually table 17-2 of mysql doc says that
# it should be 8192 + 208: http://www.mysql.org/docs/9.1/static/kernel-resources.html)
#
get_shared_buffers()
{
  local ram
  ram=$(get_system_ram)
  local shmmax
  shmmax=$(cat /proc/sys/kernel/shmmax)
  local THIRTY_TWO_MB=$((32 * 1024 * 1024))
  local EIGHT_GB=$((8 * 1024 * 1024 * 1024))
  local SIXTEEN_GB=$((16 * 1024 * 1024 * 1024))
  local shared_buffer;

  # On some systems we get value of shmmax that is out of range for integer
  # values that bash can process (see OPSAPS-11583). So we check for any
  # value that is greater than 99 GB (length > 11) and then floor shmmax value
  # to 16 GB (as 8GB is max shared buffer value, 50% of shmmax)
  if [ ${#shmmax} -gt 11 ]; then
    shmmax=$SIXTEEN_GB
  fi

  if [ "$shmmax" -eq "$THIRTY_TWO_MB" ]; then
    let "shared_buffer=shmmax / 4"
    let "shared_buffer=shared_buffer / (8192 + 208)"
    echo "shared_buffers=$shared_buffer"
  elif [ "$shmmax" -gt "$THIRTY_TWO_MB" ]; then
    let "shared_buffer=shmmax / 2"
    if [ "$shared_buffer" -gt "$EIGHT_GB" ]; then
      shared_buffer=$EIGHT_GB
    fi

    let "quarter_of_ram=ram / 4"
    if [ "$shared_buffer" -gt "$quarter_of_ram" ]; then
      shared_buffer=$quarter_of_ram
    fi

    let "shared_buffer=shared_buffer / (8192 + 208)"
    echo "shared_buffers=$shared_buffer"
  fi
}



backup_file()
{
  local FILE=$1
  if [[ -f $FILE ]] && [[ ! -f $FILE.$NOW ]]; then
    cp "$FILE" "$FILE"."$NOW"
  fi
}

wait_for_db_server_to_start()
{
    systemctl status mysqld| grep -i running
                if [ $? -eq 0 ]
                        then
                                echo "Service is running"
                                return 0
                        else
                                echo "Service is not running"
                                return 1
                fi


}
db_server_restart()
{
    systemctl restart mysqld
	if [ $? == 0 ]
		then
			log "Mysqld service restarted"
		else
			log "Getting error while restarting the mysql service"
			return 1
	fi

}


log "------- initialize-mysql.sh starting -------"

#Installing Mysql server
log "Installing mysql in the Redhat 7 server if it not installed"
rpm -qa| grep -i mysql| grep server
if [ $? == 0 ]
	then
		log "Mysql is already installed.. Skipping the installation"
else
	log "Installing the Mysql server"
	cd /tmp/
	wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm
	rpm -ivh mysql57-community-release-el7-9.noarch.rpm
	yum install mysql-server -y
	systemctl start mysqld
	tempRootDBPass="`grep 'temporary.*root@localhost' /var/log/mysqld.log | tail -n 1 | sed 's/.*root@localhost: //'`"

	#Setting password 
	mysqladmin -u root --password="$tempRootDBPass" password "$ROOTPASS"
	
	mysql -u root -p$ROOTPASS -e "GRANT ALL PRIVILEGES ON *.* TO 'temp'@'localhost' IDENTIFIED BY 'Password@123'"  #Chai#
 
systemctl status mysqld.service
echo " -> MySQL server installation completed, root password: $ROOTPASS";
systemctl restart mysqld
	
log "Checking mysqlserver is installed or not"
fi

mysql --version
if [ $? == 0 ]
  then
        log "Mysql server is installed"
  else
        log "Mysql server is not installed on the server, Please check"
        exit 1
fi

systemctl status mysqld|grep -i running

if [ $? == 0 ]
   then
        log "Mysql service is running"
else
        log "Mysql service is not running, stopping the script"
        exit 1
fi




SCM_PWD=$(create_random_password)
#SCM_PWD="Mysql@1234"  #Chai#
DATA_DIR=/var/lib/mysql
DB_HOST=$(hostname -f)
DB_PORT=${DB_PORT:-3306}
DB_HOSTPORT="$DB_HOST:$DB_PORT"
DB_PROP_FILE=/etc/cloudera-scm-server/db.properties
MGMT_DB_PROP_FILE=/etc/cloudera-scm-server/db.mgmt.properties
DB_LIST_FILE=$DATA_DIR/scm.db.list
NOW=$(date +%Y%m%d-%H%M%S)


#create_scm_db "$SCM_PWD"   #Chai#
create_db_and_user amon amon
create_db_and_user rman rman
create_db_and_user nav nav
create_db_and_user sentry sentry
create_db_and_user navms navms
create_db_and_user oozie oozie
create_db_and_user hue hue
create_db_and_user hive metastore
#create_hive_metastore

create_db


#/usr/share/cmf/schema/scm_prepare_database.sh mysqlsql scm scm "$SCM_PWD" >> "${LOG_FILE}" 2>&1   #Chai#


# restart to make sure all configuration take effects
db_server_restart

wait_for_db_server_to_start

log "------- initialize-sql.sh succeeded -------"

# always `exit 0` on success
exit 0
